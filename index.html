<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Skull Puzzle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a202c; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
        canvas { display: block; touch-action: none; }
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            padding: 0.5rem 0.75rem;
            width: auto;
            min-width: 250px; 
        }
        .bone-name { min-height: 24px; }
        .bone-description { min-height: 40px; color: #a0aec0; } 
        .button { transition: all 0.2s ease-in-out; }
        .button:hover { transform: scale(1.05); }
        #completion-message, #start-screen { display: none; }
        #VRButton { position: absolute !important; right: 12px; bottom: 12px; z-index: 70; }
    </style>
</head>
<body>
    <div id="loading-overlay" class="absolute inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 text-white">
        <p class="text-2xl">模型載入中...</p>
    </div>
    <!-- Updated background image URL to user's GitHub file -->
    <div id="start-screen" class="absolute inset-0 z-40 flex flex-col items-center justify-center bg-gray-900 text-white text-center bg-cover bg-center" style="display: flex; background-image: url('https://cdn.jsdelivr.net/gh/gp01002-code/Skeleton-/YOUR_IMAGE_URL_HERE.jpg');">
        <div class="absolute inset-0 bg-black opacity-50"></div>
        <div class="relative z-10">
            <h1 class="text-5xl font-bold mb-4" style="text-shadow: 2px 2px 8px rgba(0,0,0,0.7);">3D Skull Puzzle Game</h1>
            <p class="text-xl mb-8" style="text-shadow: 1px 1px 4px rgba(0,0,0,0.7);">Professor Wu Chun Hsueh</p>
            <button id="start-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-2xl button shadow-xl">開始體驗</button>
        </div>
    </div>
    <div id="info-panel-html" class="info-panel shadow-lg" style="display: none;">
        <div class="flex justify-between items-center">
            <h1 class="text-md font-bold text-white whitespace-nowrap">3D 頭骨拼圖</h1>
            <p id="timer-text" class="text-md text-yellow-300 font-mono ml-2">時間: 00:00</p>
        </div>
        <p id="bone-name-text" class="mt-2 text-sm text-cyan-300 font-semibold bone-name">指向一塊骨骼以查看資訊。</p>
        <p id="bone-description-text" class="mt-1 text-xs bone-description"></p>
    </div>
    <div id="completion-message" class="absolute inset-0 z-20 flex-col items-center justify-center bg-black bg-opacity-80 text-white text-center">
        <h2 class="text-6xl font-bold mb-4 animate-pulse">恭喜！</h2>
        <p class="text-2xl mb-8">您已成功拼湊出完整的頭骨！</p>
        <button id="play-again-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl button shadow-xl">再玩一次</button>
    </div>
    <button id="reset-button" class="absolute bottom-5 right-5 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-lg z-10 button shadow-lg" style="display: none;">重置</button>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let controller1, controller2;
        let playerRig;
        let vrInfoPanel;
        const clock = new THREE.Clock();
        const controllerStates = {
            controller1: { intersectedObject: null, selectedObject: null, line: null, initialRotation: new THREE.Quaternion() },
            controller2: { intersectedObject: null, selectedObject: null, line: null, initialRotation: new THREE.Quaternion() }
        };
        const draggableObjects = [];
        const bonesData = [];
        let modelsToLoad = 0;
        let placedCount = 0;
        let startTime = null;
        let timerInterval = null;
        
        // Dragging variables
        const plane = new THREE.Plane();
        const offset = new THREE.Vector3();
        const intersection = new THREE.Vector3();
        
        const boneNameText = document.getElementById('bone-name-text');
        const boneDescriptionText = document.getElementById('bone-description-text');
        const timerText = document.getElementById('timer-text');
        const completionMessage = document.getElementById('completion-message');
        const resetButton = document.getElementById('reset-button');
        const playAgainButton = document.getElementById('play-again-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const infoPanelHTML = document.getElementById('info-panel-html');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        
        const masterScale = 0.012; 
        const referencePosition = new THREE.Vector3(0, 0.02, 0); 
        const snapDistance = 0.05; // 增加吸附距離，讓拼接更容易
        const VR_MOVEMENT_SPEED = 1.0; 
        const VR_ZOOM_SPEED = 1.0; 

        const correctTargetRot = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);

        // --- BONE LIST ---
        const boneDefinitions = [
            // Top Row
            { id: 'parietal_l', name: '左頂骨', description: '構成顱頂和側面的骨骼。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/parietal_bone_01.stl', scale: masterScale, initialPos: new THREE.Vector3(0.15, 0.18, 0), targetPos: new THREE.Vector3(0.05, 0, 0) },
            { id: 'frontal', name: '額骨', description: '構成前額的骨骼。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/Frontal_bone.stl', scale: masterScale, initialPos: new THREE.Vector3(0, 0.20, 0.1), targetPos: new THREE.Vector3(0, 0, 0) },
            { id: 'parietal_r', name: '右頂骨', description: '構成顱頂和側面的骨骼。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/parietal_bone_02.stl', scale: masterScale, initialPos: new THREE.Vector3(-0.15, 0.18, 0), targetPos: new THREE.Vector3(-0.05, 0, 0) },
            
            // Middle Row
            { id: 'temporal_l', name: '左顳骨', description: '位於顱骨兩側，保護聽覺器官。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/Temporal_bone01.stl', scale: masterScale, initialPos: new THREE.Vector3(0.25, 0.05, 0), targetPos: new THREE.Vector3(0.10, 0.05, 0.1) },
            { id: 'cheek_l', name: '左顴骨', description: '構成臉頰的突出部分。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/cheekbones_01.stl', scale: masterScale, initialPos: new THREE.Vector3(0.15, 0.02, 0.1), targetPos: new THREE.Vector3(0.10, 0.05, 0.1) },
            { id: 'maxilla_l', name: '左上頷骨', description: '構成上顎的主要部分。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/maxilla_01.stl', scale: masterScale, initialPos: new THREE.Vector3(0.1, -0.03, 0.15), targetPos: new THREE.Vector3(0.05, -0.03, 0.15) },
            
            { id: 'maxilla_r', name: '右上頷骨', description: '構成上顎的主要部分。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/maxilla_02.stl', scale: masterScale, initialPos: new THREE.Vector3(-0.1, -0.03, 0.15), targetPos: new THREE.Vector3(-0.05, -0.03, 0.15) },
            { id: 'cheek_r', name: '右顴骨', description: '構成臉頰的突出部分。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/cheekbones_02.stl', scale: masterScale, initialPos: new THREE.Vector3(-0.15, 0.02, 0.1), targetPos: new THREE.Vector3(-0.05, 0.15, 0.1) },
            { id: 'temporal_r', name: '右顳骨', description: '位於顱骨兩側，保護聽覺器官。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/Temporal_bone02.stl', scale: masterScale, initialPos: new THREE.Vector3(-0.25, 0.05, 0), targetPos: new THREE.Vector3(-0.1, 0.05, 0.1) },

            // Back Row
            { id: 'occipital', name: '枕骨', description: '構成顱骨的後部和底部。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/occipital_bone.stl', scale: masterScale, initialPos: new THREE.Vector3(0, -0.04, -0.2), targetPos: new THREE.Vector3(0, -0.04, 0) },
            
            // Bottom Row
            { id: 'mandible', name: '下頷骨', description: '構成下顎，是顱骨中唯一可動的骨骼。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/mandible.stl', scale: masterScale, initialPos: new THREE.Vector3(0, -0.15, 0.1), targetPos: new THREE.Vector3(0, 0.15, 0.5) },
            
            // Inner Bones
            { id: 'sphenoid', name: '蝶骨', description: '位於顱底中部，形狀像蝴蝶。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/sphenoid_bone.stl', scale: masterScale, initialPos: new THREE.Vector3(0.0, 0.35, -0.25), targetPos: new THREE.Vector3(0.0, -1, 0) },
            { id: 'ethmoid', name: '篩骨', description: '位於兩眼眶之間，構成鼻腔頂部。', modelUrl: 'https://cdn.jsdelivr.net/gh/gp01002-code/human_skull/ethmoid_bone.stl', scale: masterScale, initialPos: new THREE.Vector3(0.0, 0.25, -0.25), targetPos: new THREE.Vector3(0.0, 0.10, 1) },
        ];
        
        startButton.addEventListener('click', () => {
            startScreen.style.display = 'none';
            loadingOverlay.style.display = 'flex';
            init();
        });

        function init() {
            scene = new THREE.Scene();
            
            const backgroundUrl = "https://cdn.jsdelivr.net/gh/gp01002-code/Skeleton-/YOUR_IMAGE_URL_HERE.jpg";
            
            new THREE.TextureLoader().load(backgroundUrl, 
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                },
                undefined,
                () => {
                    console.warn("背景圖片載入失敗，將使用預設背景。");
                    scene.background = new THREE.Color(0x1a202c);
                }
            );
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
            
            playerRig = new THREE.Group();
            scene.add(playerRig);
            playerRig.add(camera);
            camera.position.set(0, 0.1, 0.8);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            const vrButton = VRButton.createButton(renderer);
            vrButton.id = 'VRButton';
            document.body.appendChild(vrButton);
            vrButton.style.display = 'block';

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(0.5, 1, 0.75);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(referencePosition.x, referencePosition.y, referencePosition.z);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createVRInfoPanel();
            setupVRControllers();
            loadSkullReference(); 
            createBones();
            createGroundPlane();
            
            infoPanelHTML.style.display = 'block';
            resetButton.style.display = 'block';

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onPointerUp);
            
            resetButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('click', resetGame);
            
            renderer.setAnimationLoop(animate);
            
            renderer.xr.addEventListener('sessionstart', onVRSessionStart);
            renderer.xr.addEventListener('sessionend', onVRSessionEnd);
        }

        function onVRSessionStart() {
            infoPanelHTML.style.display = 'none';
            controls.enabled = false;
            playerRig.position.set(0, 0.02, 0.5);
        }

        function onVRSessionEnd() {
            infoPanelHTML.style.display = 'block';
            controls.enabled = true;
            playerRig.position.set(0, 0, 0);
            camera.position.set(0, 0.1, 0.8);
            controls.target.copy(referencePosition);
            controls.update();
        }

        function createGroundPlane() {
            const groundGeometry = new THREE.CircleGeometry(5, 64);
            const ground = new Reflector(groundGeometry, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x333333,
                recursion: 1
            });
            ground.position.y = -0.2; 
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
        }
        
        function createVRInfoPanel() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 200; 
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const geometry = new THREE.PlaneGeometry(0.2, 0.078); 
            vrInfoPanel = new THREE.Mesh(geometry, material);
            vrInfoPanel.position.set(0, 0.1, -0.2); 
            vrInfoPanel.userData.context = context;
            vrInfoPanel.userData.texture = texture;
            playerRig.add(vrInfoPanel);
        }

        function updateVRInfoPanel(bone, time) {
            if (!vrInfoPanel || !renderer.xr.isPresenting) {
                if(vrInfoPanel) vrInfoPanel.visible = false;
                return;
            }
            vrInfoPanel.visible = true;
            const context = vrInfoPanel.userData.context;
            const texture = vrInfoPanel.userData.texture;
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, 512, 200);
            context.fillStyle = 'white';
            context.font = 'bold 24px sans-serif';
            context.fillText('3D 頭骨拼圖', 10, 30);
            context.font = '24px monospace';
            context.fillText(`時間: ${time}`, 350, 30);
            
            if (bone) {
                context.fillStyle = '#00ffff';
                context.font = 'bold 30px sans-serif';
                context.fillText(bone.name, 10, 85);
                context.fillStyle = '#a0aec0';
                context.font = '22px sans-serif';
                const words = bone.description.split('');
                let line = '';
                let y = 125;
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n];
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > 490 && n > 0) {
                        context.fillText(line, 10, y);
                        line = words[n];
                        y += 25;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, 10, y);

            } else {
                 context.fillStyle = '#00ffff';
                context.font = 'bold 30px sans-serif';
                context.fillText('指向骨骼...', 10, 85);
            }
            texture.needsUpdate = true;
        }

        function onSqueeze(event) {
            if (completionMessage.style.display === 'flex') {
                resetGame();
            }
        }

        function onSelectStart(event) {
            if (completionMessage.style.display === 'flex') {
                resetGame();
                return;
            }
            if (!startTime) startTimer();
            const controller = event.target;
            const controllerName = controller.name;
            const state = controllerStates[controllerName];
            const otherControllerName = controllerName === 'controller1' ? 'controller2' : 'controller1';
            const otherState = controllerStates[otherControllerName];
            if (state.intersectedObject && !state.intersectedObject.userData.placed) {
                if (otherState.selectedObject !== state.intersectedObject) {
                    state.selectedObject = state.intersectedObject;
                    state.initialRotation.copy(state.selectedObject.quaternion);
                    controller.attach(state.selectedObject);
                    vibrate(controller, 0.3, 50);
                }
            }
        }

        function onSelectEnd(event) {
            const controller = event.target;
            const controllerName = controller.name;
            const state = controllerStates[controllerName];
            if (state.selectedObject) {
                scene.attach(state.selectedObject);
                const targetPos = state.selectedObject.userData.targetPos;
                const distance = state.selectedObject.position.distanceTo(targetPos);
                if (distance < snapDistance) {
                    state.selectedObject.position.copy(targetPos);
                    state.selectedObject.quaternion.copy(correctTargetRot);
                    state.selectedObject.userData.placed = true;
                    if (state.selectedObject.material) {
                        state.selectedObject.material.color.set(0x50c878);
                    }
                    placedCount++;
                    checkCompletion();
                    vibrate(controller, 1.0, 200);
                } else {
                    state.selectedObject.position.copy(state.selectedObject.userData.initialPos);
                    vibrate(controller, 0.2, 50);
                }
                state.selectedObject = null;
            }
        }
        
        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.name = 'controller1';
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('squeeze', onSqueeze);
            playerRig.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.name = 'controller2';
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('squeeze', onSqueeze);
            playerRig.add(controller2);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1) ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const line1 = new THREE.Line(lineGeometry, lineMaterial.clone());
            line1.scale.z = 2; 
            controller1.add(line1);
            controllerStates.controller1.line = line1;
            const line2 = new THREE.Line(lineGeometry, lineMaterial.clone());
            line2.scale.z = 2; 
            controller2.add(line2);
            controllerStates.controller2.line = line2;
        }

        function vibrate(controller, intensity = 0.5, duration = 100) {
            const session = renderer.xr.getSession();
            if (!session || !session.inputSources) return;
            
            const handedness = (controller.name === 'controller1') ? 'left' : 'right';
            const source = Array.from(session.inputSources).find(s => s.handedness === handedness);

            if (source && source.gamepad && source.gamepad.hapticActuators && source.gamepad.hapticActuators.length > 0) {
                source.gamepad.hapticActuators[0].pulse(intensity, duration);
            }
        }
        
        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            return raycaster.intersectObjects(draggableObjects, true);
        }
        function modelLoaded() {
            modelsToLoad--;
            if (modelsToLoad <= 0) {
                loadingOverlay.style.display = 'none';
            }
        }

        function loadSkullReference() {
            const loader = new STLLoader();
            const referenceMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.15,
                metalness: 0.5,
                roughness: 0.2
            });
            
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                loader.load(url, (geometry) => {
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    geometry.translate(-center.x, -center.y, -center.z);
                    
                    const mesh = new THREE.Mesh(geometry, referenceMaterial);
                    mesh.scale.set(def.scale, def.scale, def.scale);
                    mesh.position.copy(def.targetPos);
                    mesh.quaternion.copy(correctTargetRot); 
                    scene.add(mesh);
                    modelLoaded();
                }, undefined, (error) => {
                    console.error(`無法載入參考模型: ${def.id}`, error);
                    modelLoaded();
                });
            });
        }

        function createBones() {
            const stlLoader = new STLLoader();
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                stlLoader.load(url, 
                    (geometry) => {
                        const material = new THREE.MeshStandardMaterial({ color: 0xebe5d1, roughness: 0.3, metalness: 0.1 });
                        geometry.computeBoundingBox();
                        const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                        geometry.translate(-center.x, -center.y, -center.z);
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.scale.set(def.scale, def.scale, def.scale);
                        mesh.quaternion.copy(correctTargetRot); 
                        setupBone(mesh, def);
                        modelLoaded();
                    }, 
                    undefined, 
                    (error) => { 
                        console.error(`無法載入模型: ${def.id}`, error);
                        modelLoaded();
                    }
                );
            });
        }
        function setupBone(mesh, def) {
            mesh.position.copy(def.initialPos);
            mesh.userData = { 
                id: def.id, 
                name: def.name, 
                description: def.description, 
                type: 'draggable', 
                placed: false, 
                initialPos: def.initialPos.clone(), 
                targetPos: def.targetPos
            };
            
            const hitbox = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshBasicMaterial({ visible: false, wireframe: true })
            );
            const bbox = new THREE.Box3().setFromObject(mesh);
            const size = bbox.getSize(new THREE.Vector3());
            hitbox.scale.copy(size).multiplyScalar(1.2); 
            mesh.add(hitbox);

            scene.add(mesh);
            draggableObjects.push(mesh);
            bonesData.push(mesh);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function updatePointerPosition(event) {
            const pointer = event.touches ? event.touches[0] : event;
            mouse.x = (pointer.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(pointer.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            if (renderer.xr.isPresenting) return;
            if (event.touches) event.preventDefault();
            if (!startTime) startTimer();
            updatePointerPosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects, true);
            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !object.userData.type) object = object.parent;
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    controls.enabled = false;
                    if (selectedObject.material) {
                        selectedObject.userData.originalColor = selectedObject.material.color.getHex();
                        selectedObject.material.color.set(0xffff00);
                    }
                    plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(plane.normal), selectedObject.position);
                    if (raycaster.ray.intersectPlane(plane, intersection)) {
                        offset.copy(selectedObject.position).sub(intersection);
                    }
                }
            }
        }

        function onPointerMove(event) {
            if (renderer.xr.isPresenting) return;
            if (event.touches) event.preventDefault();
            updatePointerPosition(event);
            raycaster.setFromCamera(mouse, camera);
            let foundBone = null;
            if (selectedObject) {
                if (raycaster.ray.intersectPlane(plane, intersection)) {
                    selectedObject.position.copy(intersection).add(offset);
                }
                foundBone = selectedObject.userData;
            } else {
                const intersects = raycaster.intersectObjects(draggableObjects, true);
                if (intersects.length > 0) {
                    let object = intersects[0].object;
                    while (object.parent && !object.userData.type) object = object.parent;
                    if (object.userData.name && !object.userData.placed) {
                        foundBone = object.userData;
                    }
                }
            }
            if (foundBone) {
                boneNameText.textContent = foundBone.name;
                boneDescriptionText.textContent = foundBone.description;
            } else {
                boneNameText.textContent = '指向一塊骨骼以查看資訊。';
                boneDescriptionText.textContent = '';
            }
        }

        function onPointerUp(event) {
             if (renderer.xr.isPresenting) return;
            if (selectedObject) {
                if (selectedObject.material && selectedObject.userData.originalColor) {
                    selectedObject.material.color.setHex(selectedObject.userData.originalColor);
                    delete selectedObject.userData.originalColor;
                }
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                if (distance < snapDistance) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.quaternion.copy(correctTargetRot);
                    selectedObject.userData.placed = true;
                    if (selectedObject.material) {
                        selectedObject.material.color.set(0x50c878);
                    }
                    placedCount++;
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
            }
            selectedObject = null;
            controls.enabled = true;
        }
        
        function checkCompletion() {
            if (placedCount >= boneDefinitions.length) {
                stopTimer();
                completionMessage.style.display = 'flex';
                if (renderer.xr.isPresenting) {
                    if (controller1) vibrate(controller1, 1.0, 500);
                    if (controller2) vibrate(controller2, 1.0, 500);
                }
                animateCompletion();
            }
        }
        function animateCompletion() {
            let glowIntensity = 0;
            let increasing = true;
            const glowAnimation = setInterval(() => {
                if (increasing) {
                    glowIntensity += 0.02;
                    if (glowIntensity >= 0.5) increasing = false;
                } else {
                    glowIntensity -= 0.02;
                    if (glowIntensity <= 0) { clearInterval(glowAnimation); return; }
                }
                draggableObjects.forEach(obj => {
                    if (obj.material) obj.material.emissiveIntensity = glowIntensity;
                });
            }, 50);
        }
        function startTimer() { startTime = Date.now(); timerInterval = setInterval(updateTimerDisplay, 1000); }
        function stopTimer() { clearInterval(timerInterval); }
        function resetTimer() {
            stopTimer();
            startTime = null;
            timerText.textContent = "時間: 00:00";
        }
        function updateTimerDisplay() {
            if (!startTime) return;
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
            const seconds = (elapsedTime % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;
            timerText.textContent = `時間: ${timeString}`;
        }
        function resetGame() {
            completionMessage.style.display = 'none';
            resetTimer();
            placedCount = 0;
            boneNameText.textContent = '指向一塊骨骼以查看資訊。';
            boneDescriptionText.textContent = '';

            Object.keys(controllerStates).forEach(key => {
                const state = controllerStates[key];
                state.intersectedObject = null;
                state.selectedObject = null;
                if (state.line && state.line.material) state.line.material.color.set(0x00ff00);
            });
            bonesData.forEach(bone => {
                bone.userData.placed = false;
                bone.position.copy(bone.userData.initialPos);
                bone.quaternion.copy(correctTargetRot); 
                if (bone.material) {
                    bone.material.color.set(0xebe5d1);
                }
            });
        }
        
        function handleController(controller, controllerName) {
            if (!controller) return;
            const state = controllerStates[controllerName];
            if (state.selectedObject) {
                return;
            };

            const intersections = getIntersections(controller);
            const line = state.line;
            let foundBone = null;
            if (intersections.length > 0) {
                let object = intersections[0].object;
                while (object.parent && !object.userData.type) object = object.parent;
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    const otherControllerName = controllerName === 'controller1' ? 'controller2' : 'controller1';
                    const otherState = controllerStates[otherControllerName];
                    if (otherState.selectedObject === object) {
                        if (line && line.material) line.material.color.set(0xff0000);
                    } else {
                        foundBone = object;
                        if (line && line.material) line.material.color.set(0xffff00);
                    }
                } else {
                    if (line && line.material) line.material.color.set(0xff0000);
                }
            } else {
                if (line && line.material) line.material.color.set(0x00ff00);
            }
            if (state.intersectedObject !== foundBone) {
                if (state.intersectedObject && state.intersectedObject.material) {
                    state.intersectedObject.material.emissive.set(0x000000);
                }
                state.intersectedObject = foundBone;
                if (foundBone && foundBone.material) {
                    foundBone.material.emissive.set(0xffffff);
                    foundBone.material.emissiveIntensity = 0.2;
                }
            }
        }

        function handleVRLocomotion(delta) {
            const xrCamera = renderer.xr.getCamera();
            if (!playerRig) return;
            const session = renderer.xr.getSession();
            if(!session || !session.inputSources) return;

            session.inputSources.forEach(source => {
                if (source.gamepad && source.handedness === 'left') {
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const moveX = Math.abs(axes[2]) > 0.1 ? axes[2] : 0;
                        const moveZ = Math.abs(axes[3]) > 0.1 ? axes[3] : 0;
                        if (moveZ !== 0 || moveX !== 0) {
                            const forward = new THREE.Vector3(0,0,-1).applyQuaternion(xrCamera.quaternion);
                            const right = new THREE.Vector3(1,0,0).applyQuaternion(xrCamera.quaternion);
                            forward.y = 0;
                            right.y = 0;
                            forward.normalize();
                            right.normalize();
                            playerRig.position.add(forward.multiplyScalar(-moveZ * VR_MOVEMENT_SPEED * delta));
                            playerRig.position.add(right.multiplyScalar(moveX * VR_MOVEMENT_SPEED * delta));
                        }
                    }
                }
                if (source.gamepad && source.handedness === 'right') {
                   const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const dollyZ = Math.abs(axes[3]) > 0.1 ? axes[3] : 0;
                         if (dollyZ !== 0) {
                            const forward = new THREE.Vector3(0,0,-1).applyQuaternion(xrCamera.quaternion);
                            forward.y = 0;
                            forward.normalize();
                            playerRig.position.add(forward.multiplyScalar(-dollyZ * VR_ZOOM_SPEED * delta));
                        }
                   }
                }
            });
        }
        
        function animate() {
            const delta = clock.getDelta();
            
            if (!renderer.xr.isPresenting) {
                controls.update();
            }
            
            if (renderer.xr.isPresenting) {
                handleController(controller1, 'controller1');
                handleController(controller2, 'controller2');
                handleVRLocomotion(delta);
                const bone1 = controllerStates.controller1.intersectedObject;
                const bone2 = controllerStates.controller2.intersectedObject;
                const bone = bone1 ? bone1.userData : (bone2 ? bone2.userData : null);
                const time = timerText.textContent.replace('時間: ','');
                updateVRInfoPanel(bone, time);
            }
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>

